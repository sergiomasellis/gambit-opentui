import { tool } from "ai";
import { mkdir, unlink } from "node:fs/promises";
import * as path from "node:path";
import { z } from "zod";

import { MAX_FILE_CHARS, MAX_SHELL_OUTPUT, workspaceRoot } from "../config";
import { truncate } from "../lib/text";
import { applyUnifiedDiff, sanitizePatchTargets, splitUnifiedDiffByFile } from "../lib/diff";
import { relativeWorkspacePath, resolveWorkspacePath } from "../lib/workspace";
import {
  buildSlashCommandToolDescription,
  executeSlashCommand,
  loadSlashCommands,
  type SlashCommandExecution,
} from "../lib/slashCommands";

const readFileSchema = z.object({
  path: z.string().describe("File path relative to the workspace root."),
});

const writeFileSchema = z.object({
  path: z.string().describe("File path relative to the workspace root."),
  content: z.string().describe("Full file contents to write."),
});

const patchFileSchema = z.object({
  path: z.string().describe("Target file path relative to the workspace root.").optional(),
  patch: z.string().describe("Unified diff patch generated by git-style tools."),
});

const executeShellSchema = z.object({
  command: z.string().describe("Command to execute using bash -lc."),
});

const slashCommandSchema = z.object({
  name: z
    .string()
    .describe("Slash command to execute (with optional namespace). Example: 'context' or 'frontend/context'."),
  arguments: z
    .string()
    .describe("Arguments forwarded to the command; they will populate $ARGUMENTS and positional placeholders.")
    .optional(),
});

const cachedSlashCommands = await loadSlashCommands();
const slashCommandDescription = buildSlashCommandToolDescription(cachedSlashCommands);

function ensureNonEmptyString(value: unknown, label: string): string {
  if (typeof value !== "string") {
    throw new Error(`Parameter \"${label}\" must be a string.`);
  }
  const trimmed = value.trim();
  if (!trimmed) {
    throw new Error(`Parameter \"${label}\" must not be empty.`);
  }
  return trimmed;
}

const readFileTool = tool<typeof readFileSchema, string>({
  description: "Read a UTF-8 file from the workspace.",
  parameters: readFileSchema,
  execute: async ({ path }) => {
    const normalizedPath = ensureNonEmptyString(path, "path");
    const resolvedPath = resolveWorkspacePath(normalizedPath);
    const file = Bun.file(resolvedPath);
    if (!(await file.exists())) {
      return `File not found: ${relativeWorkspacePath(resolvedPath)}`;
    }
    const content = await file.text();
    return truncate(content, MAX_FILE_CHARS);
  },
});

const writeFileTool = tool<typeof writeFileSchema, string>({
  description: "Overwrite a file in the workspace with new content.",
  parameters: writeFileSchema,
  execute: async ({ path, content }) => {
    const normalizedPath = ensureNonEmptyString(path, "path");
    if (typeof content !== "string") {
      throw new Error('Parameter "content" must be a string.');
    }
    const resolvedPath = resolveWorkspacePath(normalizedPath);
    await mkdir(path.dirname(resolvedPath), { recursive: true });
    const bytesWritten = await Bun.write(resolvedPath, content);
    return `Wrote ${bytesWritten} bytes to ${relativeWorkspacePath(resolvedPath)}.`;
  },
});

const patchFileTool = tool<typeof patchFileSchema, string>({
  description: "Apply a unified diff patch to a file.",
  parameters: patchFileSchema,
  execute: async ({ path: targetPath, patch }) => {
    const normalizedPatch = ensureNonEmptyString(patch, "patch");

    if (normalizedPatch.includes("*** Begin Patch")) {
      throw new Error("apply_patch formatted patches are not supported.");
    }

    const trimmedTarget = targetPath?.trim();
    const explicitTarget = trimmedTarget
      ? relativeWorkspacePath(resolveWorkspacePath(trimmedTarget))
      : null;

    const perFilePatches = splitUnifiedDiffByFile(normalizedPatch);

    if (perFilePatches.length === 0) {
      if (!explicitTarget) {
        throw new Error("Unable to determine patch target. Provide a path parameter.");
      }

      const resolvedPath = resolveWorkspacePath(explicitTarget);
      const relativePath = relativeWorkspacePath(resolvedPath);
      sanitizePatchTargets(normalizedPatch, relativePath);

      const file = Bun.file(resolvedPath);
      const exists = await file.exists();
      const baseText = exists ? await file.text() : "";
      const updated = applyUnifiedDiff(baseText, normalizedPatch);
      const isDeletion = /\+\+\+\s+\/dev\/null/.test(normalizedPatch);

      if (isDeletion) {
        if (!exists) {
          throw new Error(`Cannot delete non-existent file: ${relativePath}`);
        }
        await unlink(resolvedPath);
        return `Deleted ${relativePath} via patch.`;
      }

      await mkdir(path.dirname(resolvedPath), { recursive: true });
      await Bun.write(resolvedPath, updated);

      return `${exists ? "Updated" : "Created"} ${relativePath} via patch.`;
    }

    if (explicitTarget && perFilePatches.length > 1) {
      throw new Error("Patch modifies multiple files. Omit the path parameter to allow this.");
    }

    const results: string[] = [];

    for (const filePatch of perFilePatches) {
      const { patchText, oldPath, newPath } = filePatch;

      const resolvedOld = oldPath ? resolveWorkspacePath(oldPath) : null;
      const resolvedNew = newPath ? resolveWorkspacePath(newPath) : null;
      const relativeOld = resolvedOld ? relativeWorkspacePath(resolvedOld) : null;
      const relativeNew = resolvedNew ? relativeWorkspacePath(resolvedNew) : null;

      const allowedTargets = [relativeOld, relativeNew].filter((value): value is string => Boolean(value));

      if (explicitTarget && !allowedTargets.includes(explicitTarget)) {
        throw new Error(`Patch modifies ${allowedTargets.join(", ")} but expected ${explicitTarget}.`);
      }

      sanitizePatchTargets(patchText, allowedTargets);

      if (!resolvedNew) {
        if (!resolvedOld) {
          throw new Error("Patch missing target path for deletion.");
        }
        const file = Bun.file(resolvedOld);
        if (!(await file.exists())) {
          throw new Error(`Cannot delete non-existent file: ${relativeOld}`);
        }
        await unlink(resolvedOld);
        results.push(`Deleted ${relativeOld} via patch.`);
        continue;
      }

      const basePath = resolvedOld ?? resolvedNew;
      const baseFile = Bun.file(basePath);
      const baseExists = await baseFile.exists();

      if (!resolvedOld && baseExists) {
        throw new Error(`Cannot create ${relativeNew}: file already exists.`);
      }

      if (resolvedOld && !(await Bun.file(resolvedOld).exists())) {
        throw new Error(`Base file not found: ${relativeOld}`);
      }

      const baseText = baseExists ? await baseFile.text() : "";
      const updated = applyUnifiedDiff(baseText, patchText);

      await mkdir(path.dirname(resolvedNew), { recursive: true });
      await Bun.write(resolvedNew, updated);

      const isRename = Boolean(resolvedOld && resolvedOld !== resolvedNew);
      const relativeResolvedNew = relativeWorkspacePath(resolvedNew);

      // Normalize path separators in messages to POSIX style for cross-platform consistency
      const toPosix = (p: string) => p.split(path.sep).join("/");

      if (isRename && resolvedOld) {
        const existingOld = Bun.file(resolvedOld);
        if (await existingOld.exists()) {
          await unlink(resolvedOld);
        }
      }

      if (isRename && relativeOld) {
        results.push(`Moved ${toPosix(relativeOld)} -> ${toPosix(relativeResolvedNew)} via patch.`);
      } else if (baseExists) {
        results.push(`Updated ${relativeResolvedNew} via patch.`);
      } else {
        results.push(`Created ${relativeResolvedNew} via patch.`);
      }
    }

    return results.length === 1 ? results[0] : results.join("\n");
  },
});

const executeShellTool = tool<typeof executeShellSchema, string>({
  description: "Execute a shell command from the workspace root.",
  parameters: executeShellSchema,
  execute: async ({ command }) => {
    if (typeof command !== "string") {
      throw new Error('Parameter "command" must be a string.');
    }

    const trimmedCommand = command.trim();
    if (!trimmedCommand) {
      return "No command provided.";
    }

    const process = Bun.spawn(["bash", "-lc", trimmedCommand], {
      cwd: workspaceRoot,
      stdout: "pipe",
      stderr: "pipe",
    });

    const [stdout, stderr, exitCode] = await Promise.all([
      process.stdout ? new Response(process.stdout).text() : Promise.resolve(""),
      process.stderr ? new Response(process.stderr).text() : Promise.resolve(""),
      process.exited,
    ]);

    const outputParts = [
      `exit_code: ${exitCode}`,
      stdout ? `stdout:\n${truncate(stdout, MAX_SHELL_OUTPUT)}` : "stdout: <empty>",
      stderr ? `stderr:\n${truncate(stderr, MAX_SHELL_OUTPUT)}` : "stderr: <empty>",
    ];

    return outputParts.join("\n\n");
  },
});

const slashCommandTool = tool<typeof slashCommandSchema, SlashCommandExecution>({
  description: slashCommandDescription,
  parameters: slashCommandSchema,
  execute: async ({ name, arguments: args }) => {
    return executeSlashCommand(name, args);
  },
});

export const agentTools = {
  readFile: readFileTool,
  writeFile: writeFileTool,
  patchFile: patchFileTool,
  executeShell: executeShellTool,
  slashCommand: slashCommandTool,
};

export type AgentTools = typeof agentTools;
